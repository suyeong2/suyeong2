head(population)
pop <-read.table("F:/work/2019/강의/시계열자료분석/timedata/population.txt")
pop2 <-as.vector(t(population))/10000
x <- 1960:1995
plot(x, pop2,type = "l")

library(ggplot2)
df<-data.frame(x,pop2)
model1<-lm(pop2~x, data=df)
summary(model1)
lines(x,model1$fitted.values,col="red",lwd=2,lty=2)

model2<-lm(pop2~x+I(x^2),data=df)
lines(x, model2$fitted.values,col="blue",lwd=2,lty=2)

predict(model2,data.frame(x=2000),interval="confidence")



library(forecast)
y <- ts(pop2, start=1960)
plot(y)
autoplot(y)+geom_smooth(method = "lm")

out2<-tslm(y~trend+I(trend^2))
fcast<-forecast(out2,h=20)
autoplot(fcst)+
  ggtitle("회귀를 이용한 예측값") +  xlab("연도")
  
out2<-tslm(y~trend)
out6<-tslm(log(y)~trend+I(trend^2))
summary(out6)#1960년을 1로 간주해서 분석한 결과임

autoplot(fcast)#1차
autoplot(fcast1, col="red")#2차?

# 예측은
fcast<-forecast(out6, h=5)

autoplot(fcast) +
  ggtitle("회귀를 이용한 예측값") +  xlab("연도")
  


a1=-0.8
a2=1.4

i<-1:100
first = a1*sin(pi*i/6 + pi/8)
second = a2*sin(pi*i/3+pi*3/4)
z=first+second

plot(1:100, z, type="o", lwd=2)

library(forecast)
z2 <- ts(z, frequency = 12)  #계절성분이 12인 seasonal time series data로 변환
#frequency=1이면 1년으로 나옴

fit1<-tslm(z2~season)
autoplot(z2)


fore1<-forecast(fit1,h=12)
autoplot(fore1)


x<-rep(1:12,10)[1:100]
year<-rep(2006:2018,each=12)[1:100]
df<-data.frame(x,z)
head(df)
out1<-lm(z~factor(x),data=df) #factor로 잡아주고 해야함
summary(out1)

df<-data.frame(x,z,year)
head(df)
out1<-lm(z~factor(x)+year,data=df)
summary(out1)


time<-1:100
SIN<-COS <- matrix(nr=length(time), nc=6)

for(i in 1:6){
  COS[,i] <- cos(2*pi*i*time/12)
  SIN[,i] <- sin(2*pi*i*time/12)
}
head(COS)
head(SIN)
